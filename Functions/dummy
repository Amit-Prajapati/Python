#!/usr/bin/python

# =============================================================================
# title           : ops-events-digest-messenger.py
# description     : This function will read all message from a SQS queue once in a week and compose a digest Email for CloudOps
#                 : Also there will be some aggregation provided to minimize duplicate messages
# author          : Amit Prajapati (502712302)
# orig revision   : 2017-07-18
# version         : 1.0
# usage           : used through Lambda, running local does read the SQS Queue as well but does not delete those after processing (they will get invisible for 5 minutes)
# notes           :
# python_version  : 2.7.10
# ==============================================================================

import boto3
import os
import json
import logging
import collections

sqsclient = boto3.client('sqs', region_name='us-east-1')
snsclient = boto3.client('sns')
queueURL = os.getenv('SQS_URL', '')
notificationARN = os.getenv('SNS_TOPIC', '')


'''
    Send SNS message to notificationARN provided through environment parameters
'''


def postToSNSTopic(subject, message):
    return snsclient.publish(
        TargetArn=notificationARN,
        Message=str(message),
        Subject=subject,
        MessageStructure='string'
    )


'''
    Posts a new message to a SQS queue which will be further used for digest notifications
'''


def postToSQSQueue(message):
    return sqsclient.send_message(
        QueueUrl=queueURL,
        MessageBody=message
    )

'''
	Update a nested dictionary or similar mapping.
	Modify ``source`` in place.
'''
def deep_update(source, overrides):
    print "Inside deep_update function"
    for key, value in overrides.iteritems():
        if isinstance(value, collections.Mapping) and value:
            returned = deep_update(source.get(key, {}), value)
            source[key] = returned
        else:
            source[key] = overrides[key]
    return source

'''
    Pulling all SQS Messages and get them deleted right afterwards
'''


def pullFromSQSQueue(debug=False):
    print "Inside pullFromSQSQueue function"
    messages = {"Messages": []}
    while True:
        currentMessages = sqsclient.receive_message(
            QueueUrl=queueURL,
            AttributeNames=[
                'ApproximateNumberOfMessages'
            ],
            MessageAttributeNames=[
                "Topic",
                "Status",
                "Details",
                "Account"
            ],
            MaxNumberOfMessages=10
        )
        print currentMessages
        if "Messages" in currentMessages and len(currentMessages["Messages"]) > 0:
            for message in currentMessages["Messages"]:
                messages["Messages"].append(message)
        else:
            return messages
        # Delete the messages
        deleteEntries = []
        for message in currentMessages["Messages"]:
            if debug:
                deleteEntries.append({
                    'Id': message['MessageId'],
                    'ReceiptHandle': message['ReceiptHandle'],
                    'VisibilityTimeout': 300
                })
            else:
                deleteEntries.append({
                    'Id': message['MessageId'],
                    'ReceiptHandle': message['ReceiptHandle']
                })
        if debug:
            response = sqsclient.change_message_visibility_batch(
                QueueUrl=queueURL,
                Entries=deleteEntries
            )
        else:
            response = sqsclient.delete_message_batch(
                QueueUrl=queueURL,
                Entries=deleteEntries
            )


def lambda_handler(event, context):
    print "Doing the needful"
    sortedData = {}
    messageString = ''
    accountSeparator = '=' * 50
    topicSeparator = '-' * 48
    topicIndent = '\n' + (' ' * 2)
    summaryIndent = '\n' + (' ' * 8)

    data = pullFromSQSQueue(event == None)
    if "Messages" in data and len(data["Messages"]) > 0:
        for message in data["Messages"]:
            print "++++++++++++++++++++++++++++++++++++++"
            print message
            firstData = False
            if "MessageAttributes" in message:
                if "Topic" in message["MessageAttributes"]:
                    if message["MessageAttributes"]["Account"]["StringValue"] in sortedData:
                        if message["MessageAttributes"]["Topic"]["StringValue"] in sortedData[
                            message["MessageAttributes"]["Account"]["StringValue"]]:
                            sortedData[message["MessageAttributes"]["Account"]["StringValue"]][
                                message["MessageAttributes"]["Topic"]["StringValue"]].append({
                                "Status": message["MessageAttributes"]["Status"]["StringValue"],
                                "Details": message["MessageAttributes"]["Details"]["StringValue"]
                            })
                        else:
                            firstData = True
                    else:
                        firstData = True
                else:
                    firstData = True
                if firstData == True:
                    deep_update(sortedData, {
                        message["MessageAttributes"]["Account"]["StringValue"]: {
                            message["MessageAttributes"]["Topic"]["StringValue"]: [{
                                "Status": message["MessageAttributes"]["Status"]["StringValue"],
                                "Details": message["MessageAttributes"]["Details"]["StringValue"]
                            }]
                        }
                    })
        # Compose Message
        for account in sortedData:
            messageString += '\n\n\n' + accountSeparator + '\n' + account + '\n' + accountSeparator + '\n'
            for topic in sortedData[account]:
                messageString += topicIndent + topic
                messageString += topicIndent + topicSeparator
                subDone = False
                uniqueStatus = set(item['Status'] for item in sortedData[account][topic])
                counts = {}
                for status in uniqueStatus:
                    for item in sortedData[account][topic]:
                        if item["Status"] == status:
                            counts[status] = counts.get(status, 0) + 1
                for item in counts:
                    messageString += summaryIndent + item + ":\t\t" + str(counts[item])
                    uniqueDetails = set(
                        detail['Details'] for detail in sortedData[account][topic] if detail['Status'] == item)
                    for detail in uniqueDetails:
                        messageString += summaryIndent + '    ' + detail
                messageString += '\n\n'
        # Print or send Message (depending on if running local or within Lambda)
        if event == None:
            print "This is the message which will get send:"
            print messageString
        else:
            postToSNSTopic('Schedules-events instances', messageString)
    else:
        print "Nothing to send at the moment, exiting"

if __name__ == "__main__":
    print "Starting local"
    lambda_handler(None, None)
