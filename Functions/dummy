#!/bin/env python

#==============================================================================
#title           : ops-scheduled-reboots/ops-scheduled-reboots-invoke.py
#description     : Lambda function which reboots instances in bulks for i.e. applying patches - this is the executing function
#author          : Andreas Pfister (105026584)
#orig revision   : 2017-03-22
#version         : 1.0
#usage           : Does run in Lambda only at the moment and should be invoked by the main function
#notes           : CONCURRENT_REBOOTS does set the amount of instances which should be rebooted at once within a 2 minutes timeframe
#                : DRY_RUN does "disarm" the function and only tests if a reboot could be done, with that you can check if the flow is working
#                : SNS_TOPIC should be self explaining, this is the topic used to send notifications if something went wrong

#                : Please use lambdadeploy (https://github.build.ge.com/pw-cloud/pw-scripts/blob/master/support/py/lambdadeploy.py) within this directory to get the whole function deployed through Cloudformation
#                : by using lambdadeploy an already existing stack will get updated and/or if only the Code got changed this will be updated as well

#python_version  : 2.7.10  
#==============================================================================

import os
import boto3
import botocore
import logging
import sys
import json
import time

logging.basicConfig()
log = logging.getLogger()
log.setLevel(logging.INFO)

logging.getLogger("boto3").setLevel(logging.ERROR)
logging.getLogger("botocore").setLevel(logging.ERROR)

client            = boto3.client('ec2')
snsclient         = boto3.client('sns')
sqsclient         = boto3.client('sqs', region_name='us-east-1')
client_lambda     = boto3.client('lambda')
notificationARN   = os.getenv('SNS_TOPIC', '')
dryRun            = os.getenv('DRY_RUN', '')
queueURL          = os.getenv('SQS_URL', '')
accountName       = os.getenv('ACCOUNT_NAME', 'NOT_SET')
dry               = dryRun == "on"

try:
	concurrentReboots = int(os.getenv('CONCURRENT_REBOOTS', '10'))
except:
	concurrentReboots = 10

'''
    Posts a new message to a SQS queue which will be further used for digest notifications
'''
def postToSQSQueue(message, details, status):
    return sqsclient.send_message(
        QueueUrl=queueURL,
        MessageBody=message,
        MessageAttributes= {
            'Topic': {
                'StringValue': 'Maintenance',
                'DataType': 'String'
            },
            'SubTopic': {
                'StringValue': 'Instance Reboot',
                'DataType': 'String'
            },
            'Status': {
                'StringValue': status,
                'DataType': 'String'
            },
            'Details': {
                'StringValue': details,
                'DataType': 'String'
            },
            'Account': {
                'StringValue': accountName,
                'DataType': 'String'    
            }
        }
    )

'''
    Send SNS message to notificationARN provided through environment parameters
'''
def postToSNSTopic(subject, message):
	if notificationARN != '':
		response = snsclient.publish(
			TargetArn=notificationARN,
			Message=str(message),
			Subject=str(subject),
			MessageStructure='string'
		)
	else:
		log.error("No NotificationARN environment variable set, cannot send notifications")

'''
	Reboot a list of instances
'''
def rebootInstance(instanceIds):
	try:
		client.reboot_instances(
			DryRun=dry,
			InstanceIds=instanceIds
		)
		for instance in instanceIds:
			postToSQSQueue("Instance Reboot", str(instance), "OK")
	except Exception as errorDetails:
		log.error('Error in rebooting the following instances: \n' + json.dumps(instanceIds, sort_keys=True, indent=4) + '\n\n' + str(errorDetails))
		for instance in instanceIds:
			postToSQSQueue("Instance Reboot", str(instance) + ": " + str(errorDetails), "Error")


#Lambda main function
def lambda_handler(event, context):
	if dry:
		log.info("We are running in dryRun Mode which does not initiate a real reboot, this is for simulating the flow")
	if 'Instances' in event:
		if len(event['Instances']) > 0:
			instanceList = event['Instances']
			rebootList = []
			iterator   = 1
			# Building list of instances to reboot
			for instance in instanceList:
				if iterator <= concurrentReboots:
					rebootList.append(instance)
				iterator += 1
			# removing the elements from the instanceList
			for instance in rebootList:
				instanceList.remove(instance)
			
			# initiating reboots, if they fail we are continuing with next "block" but sending a SNS notification
			rebootInstance(rebootList)
			
			# Some additional output in the logfiles if we are running in Dry Mode
			if dry:
				log.info("Just simulated the reboot of the following instances: " + str(rebootList))
				if len(instanceList) > 0:
					log.info(str(len(instanceList)) + " Instances left, passing those further")
				else:
					log.info("No Instances left, all done !")

			if len(instanceList) > 0:
				# Sleeping for 2 minutes and pass list further
				time.sleep(120)
				payload = { "Instances": [] }
				payload["Instances"] = instanceList
				response = client_lambda.invoke(
					FunctionName='ops-scheduled-reboots-invoke',
					InvocationType='Event',
					LogType='None',
					Payload=json.dumps(payload)
				)

	else:
		log.error('Payload is not as expected, you should pass a list of instanceIds')
		sys.exit(1)


# for local testing
if __name__ == "__main__":
	logging.basicConfig()
	lambda_handler(None, None)
